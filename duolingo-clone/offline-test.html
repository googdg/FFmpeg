<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¦»çº¿åŠŸèƒ½æµ‹è¯• - å¤šé‚»å›½å…‹éš†</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: linear-gradient(135deg, #1cb0f6 0%, #0ea5e9 100%);
            color: white;
            border-radius: 12px;
        }
        
        .section {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .section h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #1cb0f6;
            padding-bottom: 8px;
        }
        
        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .test-item:last-child {
            border-bottom: none;
        }
        
        .test-name {
            font-weight: 500;
        }
        
        .test-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .status-pass {
            background: #d4edda;
            color: #155724;
        }
        
        .status-fail {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-pending {
            background: #fff3cd;
            color: #856404;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #1cb0f6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0ea5e9;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .network-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .online {
            background: #d4edda;
            color: #155724;
        }
        
        .offline {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .dot-online {
            background: #28a745;
        }
        
        .dot-offline {
            background: #dc3545;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #1cb0f6;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ“± ç¦»çº¿åŠŸèƒ½æµ‹è¯•</h1>
        <p>æµ‹è¯•å¤šé‚»å›½å…‹éš†åº”ç”¨çš„ç¦»çº¿å­¦ä¹ åŠŸèƒ½</p>
    </div>

    <div id="networkStatus" class="network-status">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">æ£€æŸ¥ç½‘ç»œçŠ¶æ€...</span>
    </div>

    <div class="section">
        <h3>ğŸ”§ åŠŸèƒ½æµ‹è¯•</h3>
        
        <div class="test-item">
            <div class="test-name">IndexedDB æ”¯æŒ</div>
            <div class="test-status" id="indexeddb-status">å¾…æµ‹è¯•</div>
        </div>
        
        <div class="test-item">
            <div class="test-name">ç¦»çº¿æœåŠ¡åˆå§‹åŒ–</div>
            <div class="test-status" id="offline-service-status">å¾…æµ‹è¯•</div>
        </div>
        
        <div class="test-item">
            <div class="test-name">æ¨¡æ‹Ÿè¯¾ç¨‹ä¸‹è½½</div>
            <div class="test-status" id="download-status">å¾…æµ‹è¯•</div>
        </div>
        
        <div class="test-item">
            <div class="test-name">ç¦»çº¿å†…å®¹è¯»å–</div>
            <div class="test-status" id="read-status">å¾…æµ‹è¯•</div>
        </div>
        
        <div class="test-item">
            <div class="test-name">ç¦»çº¿è¿›åº¦ä¿å­˜</div>
            <div class="test-status" id="progress-status">å¾…æµ‹è¯•</div>
        </div>
        
        <div class="test-item">
            <div class="test-name">è¿›åº¦åŒæ­¥æ¨¡æ‹Ÿ</div>
            <div class="test-status" id="sync-status">å¾…æµ‹è¯•</div>
        </div>
    </div>

    <div class="section">
        <h3>ğŸ® æ“ä½œé¢æ¿</h3>
        
        <button class="btn btn-primary" onclick="runAllTests()">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
        <button class="btn btn-primary" onclick="simulateDownload()">æ¨¡æ‹Ÿä¸‹è½½è¯¾ç¨‹</button>
        <button class="btn btn-secondary" onclick="checkStorage()">æ£€æŸ¥å­˜å‚¨</button>
        <button class="btn btn-danger" onclick="clearStorage()">æ¸…ç©ºå­˜å‚¨</button>
        
        <div style="margin-top: 15px;">
            <div>ä¸‹è½½è¿›åº¦:</div>
            <div class="progress-bar">
                <div class="progress-fill" id="downloadProgress" style="width: 0%"></div>
            </div>
            <div id="downloadText" style="font-size: 12px; color: #666; margin-top: 4px;">
                å‡†å¤‡å¼€å§‹...
            </div>
        </div>
    </div>

    <div class="section">
        <h3>ğŸ“‹ æµ‹è¯•æ—¥å¿—</h3>
        <div class="log" id="testLog">ç­‰å¾…æµ‹è¯•å¼€å§‹...\n</div>
        <button class="btn btn-secondary" onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
    </div>

    <script>
        // ç®€åŒ–çš„ç¦»çº¿æœåŠ¡å®ç°ï¼ˆç”¨äºæµ‹è¯•ï¼‰
        class SimpleOfflineService {
            constructor() {
                this.dbName = 'duolingo-test';
                this.dbVersion = 1;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('content')) {
                            const contentStore = db.createObjectStore('content', { keyPath: 'id' });
                            contentStore.createIndex('type', 'type', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('progress')) {
                            db.createObjectStore('progress', { keyPath: 'sessionId' });
                        }
                    };
                });
            }

            async saveContent(content) {
                const transaction = this.db.transaction(['content'], 'readwrite');
                const store = transaction.objectStore('content');
                return store.put(content);
            }

            async getContent(id) {
                const transaction = this.db.transaction(['content'], 'readonly');
                const store = transaction.objectStore('content');
                return new Promise((resolve, reject) => {
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveProgress(progress) {
                const transaction = this.db.transaction(['progress'], 'readwrite');
                const store = transaction.objectStore('progress');
                return store.put(progress);
            }

            async getAllContent() {
                const transaction = this.db.transaction(['content'], 'readonly');
                const store = transaction.objectStore('content');
                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async clearAll() {
                const transaction = this.db.transaction(['content', 'progress'], 'readwrite');
                await Promise.all([
                    transaction.objectStore('content').clear(),
                    transaction.objectStore('progress').clear()
                ]);
            }
        }

        // å…¨å±€å˜é‡
        let offlineService = new SimpleOfflineService();
        let testLog = '';

        // æ—¥å¿—å‡½æ•°
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            testLog += `[${timestamp}] ${message}\n`;
            document.getElementById('testLog').textContent = testLog;
            document.getElementById('testLog').scrollTop = document.getElementById('testLog').scrollHeight;
        }

        function clearLog() {
            testLog = '';
            document.getElementById('testLog').textContent = 'æ—¥å¿—å·²æ¸…ç©º...\n';
        }

        // æ›´æ–°æµ‹è¯•çŠ¶æ€
        function updateTestStatus(testId, status, message = '') {
            const element = document.getElementById(testId + '-status');
            element.className = 'test-status status-' + status;
            element.textContent = message || status;
        }

        // ç½‘ç»œçŠ¶æ€ç›‘æ§
        function updateNetworkStatus() {
            const isOnline = navigator.onLine;
            const statusDiv = document.getElementById('networkStatus');
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (isOnline) {
                statusDiv.className = 'network-status online';
                statusDot.className = 'status-dot dot-online';
                statusText.textContent = 'åœ¨çº¿æ¨¡å¼';
            } else {
                statusDiv.className = 'network-status offline';
                statusDot.className = 'status-dot dot-offline';
                statusText.textContent = 'ç¦»çº¿æ¨¡å¼';
            }
        }

        // æµ‹è¯•å‡½æ•°
        async function testIndexedDB() {
            try {
                if (!window.indexedDB) {
                    throw new Error('IndexedDB not supported');
                }
                updateTestStatus('indexeddb', 'pass', 'æ”¯æŒ');
                log('âœ… IndexedDB æ”¯æŒæ£€æŸ¥é€šè¿‡');
                return true;
            } catch (error) {
                updateTestStatus('indexeddb', 'fail', 'ä¸æ”¯æŒ');
                log('âŒ IndexedDB æ”¯æŒæ£€æŸ¥å¤±è´¥: ' + error.message);
                return false;
            }
        }

        async function testOfflineServiceInit() {
            try {
                await offlineService.init();
                updateTestStatus('offline-service', 'pass', 'åˆå§‹åŒ–æˆåŠŸ');
                log('âœ… ç¦»çº¿æœåŠ¡åˆå§‹åŒ–æˆåŠŸ');
                return true;
            } catch (error) {
                updateTestStatus('offline-service', 'fail', 'åˆå§‹åŒ–å¤±è´¥');
                log('âŒ ç¦»çº¿æœåŠ¡åˆå§‹åŒ–å¤±è´¥: ' + error.message);
                return false;
            }
        }

        async function testDownload() {
            try {
                updateTestStatus('download', 'pending', 'ä¸‹è½½ä¸­...');
                log('ğŸ“¥ å¼€å§‹æ¨¡æ‹Ÿè¯¾ç¨‹ä¸‹è½½...');
                
                // æ¨¡æ‹Ÿè¯¾ç¨‹æ•°æ®
                const mockCourse = {
                    id: 'course_test',
                    type: 'course',
                    data: {
                        id: 'test-course',
                        name: 'æµ‹è¯•è¯¾ç¨‹',
                        units: [
                            {
                                id: 'unit-1',
                                name: 'å•å…ƒ1',
                                skills: [
                                    {
                                        id: 'skill-1',
                                        name: 'æŠ€èƒ½1',
                                        lessons: [
                                            { id: 'lesson-1', name: 'è¯¾ç¨‹1' },
                                            { id: 'lesson-2', name: 'è¯¾ç¨‹2' }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    downloadedAt: new Date(),
                    size: 1024
                };
                
                // æ¨¡æ‹Ÿä¸‹è½½è¿›åº¦
                for (let i = 0; i <= 100; i += 10) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    updateDownloadProgress(i, `ä¸‹è½½è¯¾ç¨‹å†…å®¹... ${i}%`);
                }
                
                await offlineService.saveContent(mockCourse);
                
                updateTestStatus('download', 'pass', 'ä¸‹è½½å®Œæˆ');
                log('âœ… æ¨¡æ‹Ÿè¯¾ç¨‹ä¸‹è½½å®Œæˆ');
                return true;
            } catch (error) {
                updateTestStatus('download', 'fail', 'ä¸‹è½½å¤±è´¥');
                log('âŒ æ¨¡æ‹Ÿè¯¾ç¨‹ä¸‹è½½å¤±è´¥: ' + error.message);
                return false;
            }
        }

        async function testRead() {
            try {
                const content = await offlineService.getContent('course_test');
                if (content && content.data) {
                    updateTestStatus('read', 'pass', 'è¯»å–æˆåŠŸ');
                    log('âœ… ç¦»çº¿å†…å®¹è¯»å–æˆåŠŸ: ' + content.data.name);
                    return true;
                } else {
                    throw new Error('No content found');
                }
            } catch (error) {
                updateTestStatus('read', 'fail', 'è¯»å–å¤±è´¥');
                log('âŒ ç¦»çº¿å†…å®¹è¯»å–å¤±è´¥: ' + error.message);
                return false;
            }
        }

        async function testProgress() {
            try {
                const mockProgress = {
                    sessionId: 'session_test_' + Date.now(),
                    lessonId: 'lesson-1',
                    exercises: [],
                    currentIndex: 0,
                    answers: [
                        { exerciseId: 'ex1', isCorrect: true },
                        { exerciseId: 'ex2', isCorrect: false }
                    ],
                    startedAt: new Date(),
                    isCompleted: true
                };
                
                await offlineService.saveProgress(mockProgress);
                
                updateTestStatus('progress', 'pass', 'ä¿å­˜æˆåŠŸ');
                log('âœ… ç¦»çº¿è¿›åº¦ä¿å­˜æˆåŠŸ');
                return true;
            } catch (error) {
                updateTestStatus('progress', 'fail', 'ä¿å­˜å¤±è´¥');
                log('âŒ ç¦»çº¿è¿›åº¦ä¿å­˜å¤±è´¥: ' + error.message);
                return false;
            }
        }

        async function testSync() {
            try {
                // æ¨¡æ‹ŸåŒæ­¥åˆ°æœåŠ¡å™¨
                log('ğŸ“¡ æ¨¡æ‹ŸåŒæ­¥è¿›åº¦åˆ°æœåŠ¡å™¨...');
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                updateTestStatus('sync', 'pass', 'åŒæ­¥æˆåŠŸ');
                log('âœ… è¿›åº¦åŒæ­¥æ¨¡æ‹Ÿå®Œæˆ');
                return true;
            } catch (error) {
                updateTestStatus('sync', 'fail', 'åŒæ­¥å¤±è´¥');
                log('âŒ è¿›åº¦åŒæ­¥æ¨¡æ‹Ÿå¤±è´¥: ' + error.message);
                return false;
            }
        }

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        async function runAllTests() {
            log('ğŸš€ å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯•...');
            
            const tests = [
                { name: 'IndexedDBæ”¯æŒ', fn: testIndexedDB },
                { name: 'ç¦»çº¿æœåŠ¡åˆå§‹åŒ–', fn: testOfflineServiceInit },
                { name: 'æ¨¡æ‹Ÿè¯¾ç¨‹ä¸‹è½½', fn: testDownload },
                { name: 'ç¦»çº¿å†…å®¹è¯»å–', fn: testRead },
                { name: 'ç¦»çº¿è¿›åº¦ä¿å­˜', fn: testProgress },
                { name: 'è¿›åº¦åŒæ­¥æ¨¡æ‹Ÿ', fn: testSync }
            ];
            
            let passed = 0;
            for (const test of tests) {
                log(`ğŸ”„ è¿è¡Œæµ‹è¯•: ${test.name}`);
                const result = await test.fn();
                if (result) passed++;
            }
            
            log(`\nğŸ“Š æµ‹è¯•å®Œæˆ! é€šè¿‡: ${passed}/${tests.length}`);
            
            if (passed === tests.length) {
                log('ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡! ç¦»çº¿åŠŸèƒ½æ­£å¸¸å·¥ä½œ');
            } else {
                log('âš ï¸ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç›¸å…³åŠŸèƒ½');
            }
        }

        // æ¨¡æ‹Ÿä¸‹è½½
        async function simulateDownload() {
            await testDownload();
        }

        // æ£€æŸ¥å­˜å‚¨
        async function checkStorage() {
            try {
                const contents = await offlineService.getAllContent();
                log(`ğŸ“Š å­˜å‚¨æ£€æŸ¥: æ‰¾åˆ° ${contents.length} ä¸ªç¦»çº¿å†…å®¹`);
                
                contents.forEach((content, index) => {
                    log(`  ${index + 1}. ${content.id} (${content.type}) - ${content.size} bytes`);
                });
                
                if (contents.length === 0) {
                    log('ğŸ’¡ æç¤º: æ²¡æœ‰æ‰¾åˆ°ç¦»çº¿å†…å®¹ï¼Œè¯·å…ˆä¸‹è½½è¯¾ç¨‹');
                }
            } catch (error) {
                log('âŒ å­˜å‚¨æ£€æŸ¥å¤±è´¥: ' + error.message);
            }
        }

        // æ¸…ç©ºå­˜å‚¨
        async function clearStorage() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç¦»çº¿å­˜å‚¨å—ï¼Ÿ')) {
                try {
                    await offlineService.clearAll();
                    log('ğŸ—‘ï¸ ç¦»çº¿å­˜å‚¨å·²æ¸…ç©º');
                    
                    // é‡ç½®æ‰€æœ‰æµ‹è¯•çŠ¶æ€
                    ['indexeddb', 'offline-service', 'download', 'read', 'progress', 'sync'].forEach(testId => {
                        updateTestStatus(testId, 'pending', 'å¾…æµ‹è¯•');
                    });
                    
                    updateDownloadProgress(0, 'å‡†å¤‡å¼€å§‹...');
                } catch (error) {
                    log('âŒ æ¸…ç©ºå­˜å‚¨å¤±è´¥: ' + error.message);
                }
            }
        }

        // æ›´æ–°ä¸‹è½½è¿›åº¦
        function updateDownloadProgress(progress, text) {
            document.getElementById('downloadProgress').style.width = progress + '%';
            document.getElementById('downloadText').textContent = text;
        }

        // åˆå§‹åŒ–
        window.addEventListener('load', () => {
            updateNetworkStatus();
            log('ğŸ”§ ç¦»çº¿åŠŸèƒ½æµ‹è¯•é¡µé¢å·²åŠ è½½');
            log('ğŸ’¡ ç‚¹å‡»"è¿è¡Œæ‰€æœ‰æµ‹è¯•"å¼€å§‹æµ‹è¯•ç¦»çº¿åŠŸèƒ½');
        });

        // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–
        window.addEventListener('online', () => {
            updateNetworkStatus();
            log('ğŸŒ ç½‘ç»œå·²è¿æ¥');
        });

        window.addEventListener('offline', () => {
            updateNetworkStatus();
            log('ğŸ“± ç½‘ç»œå·²æ–­å¼€ï¼Œè¿›å…¥ç¦»çº¿æ¨¡å¼');
        });
    </script>
</body>
</html>